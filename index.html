<!DOCTYPE html>
<html>
<head>
<title>RUANG site</title>
<style>
body {
background-color:whitesmoke
}
.article-panel {
background-color: #f9f9f9;
padding: 20px;
border-radius: 5px;
box-shadow: 0 2px 5px rgba(0,0,0,0.1);
margin-bottom: 20px;
}
.article-title {
font-size: 1.5em;
margin-bottom: 10px;
}
.article-date {
color: #777;
margin-bottom: 10px;
}
.article-content {
line-height: 1.6;
}
</style>
</head>
<body>
<h1 style="text-align: left;">RUANG site</h1>
<div class="row1">
<p style="text-align: left;">
<a href="http://www.github.com/rruuaanng"><b>github</b></a> |
<a href="notes/"><b>notes</b></a> |
</p>
</div>
<hr><div class="blog">
<ul>

<li class="panel">
<div class="title">pymalloc</div>
<div class="time">2024/10/9</div>
<div class="author">RUANG</div>
<div class="content">
<h1>Hello</h1>
<p>Welcome to my site.</p>
</div>
</li>


<li class="panel">
<div class="title">pymalloc</div>
<div class="time">2024/10/9</div>
<div class="author">RUANG</div>
<div class="content">
<h1>pymalloc</h1>
<p>The default memory allocation strategy in CPython (which also includes mimalloc) is designed to allocate small objects (under 512 bytes) more efficiently by preallocating a certain number of memory blocks, thereby reducing the frequency of allocation requests. Additionally, it is optimized for multi-threaded environments, primarily through the use of the Global Interpreter Lock (GIL). The specific implementation can be found in the source code directory<code>Object/obmalloc.c</code>.</p>
<h2>Implementation</h2>
<h3>Principle</h3>
<h3>Allocation process</h3>
<h3>pool_header structure</h3>
<p>```C
/<em> When you say memory, my mind reasons in terms of (pointers to) blocks </em>/
typedef uint8_t pymem_block;</p>
<p>/<em> Pool for small blocks. </em>/
struct pool_header {
    union { pymem_block <em>_padding;
            uint count; } ref;          /</em> number of allocated blocks    <em>/
    pymem_block </em>freeblock;             /<em> pool's free list head         </em>/
    struct pool_header <em>nextpool;       /</em> next pool of this size class  <em>/
    struct pool_header </em>prevpool;       /<em> previous pool       ""        </em>/
    uint arenaindex;                    /<em> index into arenas of base adr </em>/
    uint szidx;                         /<em> block size class index        </em>/
    uint nextoffset;                    /<em> bytes to virgin block         </em>/
    uint maxnextoffset;                 /<em> largest valid nextoffset      </em>/
};
```</p>
<h3>Public API</h3>
<ul>
<li>void *PyMem_Malloc(size_t size)</li>
<li>void *PyMem_Calloc(size_t nelem, size_t elsize)</li>
<li>void <em>PyMem_Realloc(void </em>ptr, size_t new_size)</li>
<li>void PyMem_Free(void *ptr)</li>
</ul>
<h3>Private API</h3>
<ul>
<li>void<em> _PyObject_Malloc(void </em>ctx, size_t size)</li>
<li>void<em> _PyObject_Calloc(void </em>ctx, size_t nelem, size_t elsize)</li>
<li>void<em> _PyObject_Realloc(void </em>ctx, void *ptr, size_t size)</li>
<li>void _PyObject_Free(void <em>ctx, void </em>p)</li>
</ul>
</div>
</li>


</ul>
</div><hr>
</body>
</html>
